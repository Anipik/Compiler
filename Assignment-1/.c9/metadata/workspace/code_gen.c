{"changed":false,"filter":false,"title":"code_gen.c","tooltip":"/code_gen.c","value":"#include <stdio.h>\n#include \"lex.h\"\n#include \"name.c\"\n#include \"lex.c\"\n\nchar    *factor     ( void );\nchar    *term       ( void );\nchar    *expression ( void );\nchar    *relation   ( void );\n\nextern char *newname( void       );\nextern void freename( char *name );\nextern int loop_count;\nextern FILE *fp;\n\nstatements()\n{\n    /* stmt -> id := expr | if expr then stmt | while expr do stmt | begin opt_stmt   */\n    while( !match(EOI) )\n    {\n        statement();\n    }\n}\n\nstatement()\n{\n    /*  statements -> expression SEMI  |  expression SEMI statements  */\n\n    int loop_local, id_len;\n    char *tempvar, *id;\n\n    if( match (IF) )\n    {\n        \n        advance();\n        tempvar = relation();\n        fprintf(fp, \"   IfZ %s Goto _L%d\\n\",tempvar,loop_count);\n        freename(tempvar);\n        loop_local = loop_count;\n        loop_count++;\n        if( match(THEN) )\n        {\n            advance();\n            statement();\n            \n            fprintf(fp, \"_L%d:\\n\",loop_local);\n        }\n        else\n        {\n            fprintf(stderr, \"%d: No THEN block after IF\\n\", yylineno );\n        }\n    }\n    \n    else if( match(WHILE) )\n    {\n        advance();\n        fprintf(fp, \" _L%d:\\n\",loop_count);\n        loop_local = loop_count;\n        loop_count++;\n        tempvar = relation();\n        fprintf(fp, \"    IfZ %s Goto _L%d\\n\",tempvar,loop_count);\n        if( match(DO) )\n        {\n            advance();\n            statement();\n            fprintf(fp, \"    Goto _L%d\\n\",loop_local);\n            fprintf(fp, \"_L%d:\\n\",loop_count);\n        }\n        else\n        {\n            fprintf(stderr, \"%d: No DO block after WHILE\\n\", yylineno);   \n        }\n    }\n    \n    else if ( match (BEGIN) )\n    {\n        advance();\n        while (!match(END) && !match (EOF) )\n            statement();\n        if ( match (EOF) )\n            fprintf(stderr, \"%d: No END statement after BEGIN\\n\", yylineno );\n        else\n            advance();\n        return 0;\n    }\n    \n    else if( match(ID) )\n    {\n        id = yytext;\n        id_len = yyleng;\n        advance();\n        if( match(COL) )\n        {\n            advance();\n            if ( match(EQUALS) ) {\n                advance();\n                tempvar = relation();\n                fprintf(fp, \"    %0.*s = %s\\n\", id_len, id, tempvar);\n            }\n            else\n                fprintf(stderr, \"%d: no equal to after : in assignment operator\\n\", yylineno );\n        }\n        else {\n            yytext = id;\n            yyleng = 0;\n            advance();\n            tempvar = relation();\n        }\n        if( match( SEMI ) )\n                advance();\n        else\n            fprintf(stderr, \"%d: Inserting missing semicolon\\n\", yylineno );\n        freename( tempvar );\n    }\n    else {\n        tempvar = relation();\n        \n        if( match( SEMI ) )\n                advance();\n            else\n                fprintf(stderr, \"%d: Inserting missing semicolon\\n\", yylineno );\n    \n            freename( tempvar );\n    }\n}\n\nchar *relation()\n{\n    char *tempvar, *tempvar2;\n    tempvar = expression();\n    if ( match(LT) || match(GT) || match(EQUALS) )\n    {\n        char symbol = *yytext;\n        advance();\n        // fprintf(fp, \"%c %d\\n\",symbol, symbol == EQUALS);\n        if ( match(EQUALS) )\n        {\n            char symbol2 = *yytext;\n            advance();\n            tempvar2 = relation();\n            fprintf(fp, \"    %s = %s %c%c %s\\n\", tempvar, tempvar, symbol, symbol2, tempvar2 );\n        }\n        else {\n            if ( symbol == '=' )\n                fprintf(fp, stderr, \"%s\\n\", \"Missing = for comparision operator\");\n            tempvar2 = relation();\n            fprintf(fp, \"    %s = %s %c %s\\n\", tempvar, tempvar, symbol, tempvar2 );\n        }\n        freename( tempvar2 );   \n    }\n    return tempvar;\n}\n\nchar    *expression()\n{\n    /* expression -> term expression'\n     * expression' -> PLUS term expression' |  epsilon\n     */\n\n    char  *tempvar, *tempvar2;\n\n    tempvar = term();\n    while( match( PLUS ) || match( MINUS ) )\n    {\n        char symbol = *yytext;\n        advance();\n        tempvar2 = term();\n        fprintf(fp, \"    %s %c= %s\\n\", tempvar, symbol, tempvar2 );\n        freename( tempvar2 );\n    }\n\n    return tempvar;\n}\n\nchar    *term()\n{\n    char  *tempvar, *tempvar2 ;\n\n    tempvar = factor();\n    while( match( TIMES ) || match (DIV) )\n    {\n        char symbol = *yytext;\n        advance();\n        tempvar2 = factor();\n        fprintf(fp, \"    %s %c= %s\\n\", tempvar, symbol, tempvar2 );\n        freename( tempvar2 );\n    }\n\n    return tempvar;\n}\n\nchar    *factor()\n{\n    char *tempvar;\n\n    if( match(NUM_OR_ID) )\n    {\n\t/* Print the assignment instruction. The %0.*s conversion is a form of\n\t * %X.Ys, where X is the field width and Y is the maximum number of\n\t * characters that will be printed (even if the string is longer). I'm\n\t * using the %0.*s to print the string because it's not \\0 terminated.\n\t * The field has a default width of 0, but it will grow the size needed\n\t * to print the string. The \".*\" tells fprintf(fp, ) to take the maximum-\n\t * number-of-characters count from the next argument (yyleng).\n\t */\n\n        fprintf(fp, \"    %s = %0.*s\\n\", tempvar = newname(), yyleng, yytext );\n        advance();\n    }\n    else if( match(LP) )\n    {\n        advance();\n        tempvar = relation();\n        if( match(RP) )\n            advance();\n        else\n            fprintf(fp, stderr, \"%d: Mismatched parenthesis\\n\", yylineno );\n    }\n    else\n\tfprintf(stderr, \"%d: Number or identifier expected\\n\", yylineno );\n\n    return tempvar;\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":2700,"scrollleft":0,"selection":{"start":{"row":64,"column":24},"end":{"row":64,"column":24},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":206,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1454566819000}